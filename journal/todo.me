.fo 'Xap'%'Assignment Journal'
\" view this file in a terminal with the command nroff -me todo.me margins.me | less -R
\" or by using groff -me -Tps todo.me > todo.ps, then opening todo.ps with any pdf file
\" viewer (assuming they support PostScript files)
.ls 2
.sp 6
.ce 1
.b "Systhmata Polymeswn Assignment Journal -- Xap"
.sp 6
.he ''Systhmata Polymeswn Assignment Journal''' \" this is here so it only exists after the 2nd page
.pp GSM 06.10 recommendation! Poso koul!
.sh 1 "Eksoikeiwsh me ekfwnhsh -- 24.12.24"
.pp
Ti mas zhtaei h ekfwnhsh tou 1ou paradoteou; Wrapper to read/write
160 samples from a .wav file. Check out what those weird functions
in the pictures mean.
.pp
Also this journal will either be in english or greeklish because
groff can't handle greek characters well.
.sh 2 "Baby steps"
.pp
Exw ton akoloythw kwdika:
.(q
LARc: np.ndarray, curr_frame_st_resd: np.ndarray = RPE_frame_st_coder(
s0: np.ndarray
)
.)q
Afto shmainei oti h synarthsh
.i RPE_frame_st_coder
pairnei san argument to 
.i s0 , 
to opoio einai numpy array,
kai exei return values dyo numpy arrays, poy ginontai
assign sta 
.i LARc ,
kai 
.i curr_frame_st_resd .
Apo,ti katalavainw sto prwto paradoteo prepei apo to s0
na vroume ta LARc kai curr_frame_st_resd (current frame short term residual)
kai epeita na kanoume thn antistrofh diadikasia ths apokwdikopoihshs, apo ta LARc
kai to curr_frame_st_resd na vroume to s0. Prwto vhma eksakolouthei na einai
to na melethsw th domh enos .wav arxeiou. 
.pp 
I know we have a wav file of 8kHz sampling rate, but how many bits in a sample?
8 or 16? Do we need to support both? The provided sample wav file has 16 bits
per sample.
.pp
Using python's
.i wave
module, interfacing with .wav files seems quite easy and straightforward.
.sh 2 "Taking a break -- audio_wrapper.py"
.pp
I have all I need to be able to read 160 frames from a .wav file. Implement
a function named 
.i audio_wrapper_read_data
to do exactly that. Gia twra paw na kanw ena dialleimma plenontas piata kai 
trwgontas meshmeriano. 
.pp 
E, na mhn pesw kai gia mia meshmerianh siesta!!!
.sh 2 "Implementing audio_wrapper_read_data()"
.pp
I've returned, and I am storing 160 samples in a numpy array called s0,
but it seems it is passed as a string? So s0 only has one element, that of
all the samples of the audio data. I need to find some way to make the 
.i "audio_data.readframes()"
function return an array of bytes instead of a string, or a singular element,
whichever it is. I have a suspicion that the samples are in buffer-like 
objects and I can laod them in via the 
.i "numpy.frombuffer()"
function.
.pp
I felt really tired and gave up for today... There's always tomorrow!
.sh 1 "audio_wrapper_read_data() continuation -- 25/12/24"
.pp
Only started working in the evening. I asked ChatGPT how to convert from
readframes() to numpy array. 
.pp
The results are in! Using numpy.frombuffer() and changing the
dtype depending on sample width (8 or 16-bit), creates a two-dimensional 
1x160 numpy array. If I then ravel() it, I get my precious one-dimensional
numpy byte array. audio_wrapper_read_data() is finished! It also quits 
if the .wav file doesn't have 8 or 16 bits per sample. 
.sh 2 "Planning for the future"
.pp
I talked with Giwrgos about the structure of this assignment. I'm to
implement the read aspect of the audio wrapper (already done) and the 
encoder part. I should make my own branch for the encoder. The encoder
should be on a separate file (separate even to the decoder) and another
.q main
-like file should call everything from a central point. 
.pp 
Giwrgos made a good point, it doesn't matter how many times I call
audio_wrapper_read_data(), it will only get the first 160 samples of the wav
file. When I complete the encoder, I should test it with a modified 
audio_wrapper_read_data() function. It will make use of a counter of how
many times I called it and audio_data.setpos() to set the required offset.
.pp
I'm feeling quite sleepy at 22:20 p.m., so I should make me some light food
and then go to bed early, Thursday is a day of work but Friday will be 
dedicated to accompanying my dad on a work-related trip, so that day will be 
wasted.
.sh 1 "Decoder 1st deliverable start -- 26/12/24"
.pp 
Started really late, 13:30 p.m. Pretty frustrated and angry that I spent
most of my night and my morning played brain-dead video games on my phone. 
I have now deleted all of them and I vow to not install any more in the near
future. But for now let's calm down and focus on this.
.pp 
At some point I should check out how to 
.i "import local files"
and 
.i "return multiple variables"
from a function in python. For now I'll start with the 
.i RPE_frame_st_coder()
function. Pws vriskw ta LARc kai curr_frame_st_resd; H mallon akoma
kalytera, poio apo ta dyo prepei na vrw prwto kai pws; Kseroume oti 
vriskomaste sto short term analysis. Ok prwta ypologizoume ta LARc kai meta
to short term residual. Omws pws ypologizoume ta ak? Pws xrhsimopoioume thn 
Rw = r?
.sh 2 "Calculating LARc using normal equations"
.pp
Ok, so this is easier than it seems. rs(k) = Sum(s(i)s(i-k)), where
s = [k, 159] and k = 0,1,...,8. Since we know all rs(k)s, we can
calculate a1,a2,...,a8 from the normal matrix equations. Let's
do it! 
.pp
The autocorrelations are done, seems like that was pretty easy.
